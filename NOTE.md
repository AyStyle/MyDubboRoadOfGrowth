# Dubbo
Dubbo是一款高性能的Java RPC 框架

## 项目架构演变过程
单体架构到微服务架构的演变，案例：拉勾网架构演变

### 单体架构
+ 优点
   1. 小项目开发快成本低
   2. 架构简单
   3. 易于测试
   4. 易于部署
   
+ 缺点
   1. 大项目模块耦合严重，不易于开发和维护，且沟通成本高
   2. 新增业务困难
   3. 核心业务与边缘业务混合在一起，出现问题相互影响
   
### 垂直架构
+ 优点
   1. 系统拆分实现了流量分担，解决了并发问题
   2. 可以针对不同系统进行优化
   3. 方便水平扩展，负载均衡，容错率提高
   4. 系统间相互独立，互不影响，新业务迭代时更加高效
   
+ 缺点
   1. 服务系统之间接口调用硬编码
   2. 搭建集群之后，实现负载均衡比较复杂
   3. 服务系统接口调用监控不到位，调用方式不统一
   4. 服务监控不到位
   5. 数据库资源浪费，充斥着慢查询，主从同步延迟大

### 分布式架构 （SOA）
+ 分层：按照业务性质分层，每一层要求简单和易于维护

     1. 应用层：
           ```
           距离用户最近的一层，也称之为接入层。使用Tomcat作为web容器，
           接收用户请求并使用下游的Dubbo提供的接口返回数据，并且该层禁止访问数据库
           ```
     2. 业务层：
          ```
          拉钩网招聘业务的核心、账号、简历、公司和职位
          ```
     3. 服务层：
           ```
           通用服务、消息服务、短链接、附件解析和定时任务平台
           这一层与业务无关，这一层的特点是：请求量大、逻辑简单、特性明显、功能独立
           ```            
     4. 存储层：
           ```
           不同的存储类型Mysql MongoDB ES FastDFS
           ```

+ 分级：按照业务性质分层，同一层的业务也要做好分级，依据业务的重要性进行分级，按照二八定律
     网站80%的流量都在核心功能上面要优先保证核心业务的稳定。
     
     
+ 隔离：不同性质、不同重要性的业务做好隔离，包括：业务、缓存、DB、中间件都要做好隔离，
     比如：核心业务的数据库要和活动相关的数据库隔离
     
+ 调用：总体上调用要单相可以跨级调用，但不容许逆向调用     
     
+ 优点：
   1. 服务以接口为粒度，为开发者屏蔽远程调用底层细节
   2. 业务分层以后架构更加清晰，并且每个业务模块职责单一，扩展性更强
   3. 数据隔离，权限回收，数据访问都通过接口，让系统更加稳定安全
   4. 服务应用本身无状态化（这里的无状态化指的是应用本身不做内存级缓存，而是把数据存入db）
   5. 服务责任易确定，每个服务可以确定责任人，这样更容易保证服务质量和稳定
   
+ 缺点：
   1. 粒度控制复杂，如果没有控制好服务的粒度，服务的模块就会越来越多，就会引发超时分布式事务等问题
   2. 服务接口数量不宜控制，容易引发接口爆炸，所以服务接口建议以业务场景进行单位划分，并对相近的业务做抽象，防止接口爆炸
   3. 版本升级兼容困难，尽量不要删除方法、字段，并且枚举类型字段的新增也容易导致不兼容
   4. 调用链路长服务质量不可监控，下游抖动可能会影响到上游业务最终形成连锁反应，导致服务质量不稳定
   
### 微服务架构

## Dubbo架构与实战
### Dubbo处理流程
+ 节点说明：

   | 节点|角色名称|
   |:---:|:---|
   |Provider|暴露服务的服务提供方|
   |Consumer|远程服务的服务消费方|
   |Registry|服务注册与发现的注册中心|
   |Monitor|统计服务的调用次数和调用时间的监控中心|
   |Container|服务运行容器，负责启动、加载、运行服务的提供者|
   
+ 调用关系说明：
   虚线代表异步调用，实线代表同步访问
   蓝色虚线：启动时完成
   红色虚线：程序运行中执行的功能
   
+ 调用流程：
  1. 容器启动服务提供方
  2. 服务提供方向注册中心注册服务，如果服务有变更，则会通知注册中心
  3. 服务消费者向注册中心订阅服务，如果服务有变更，则注册中心会通知
  4. 服务消费者调用服务提供者，基于软负载均衡算法选择一台服务提供者，如果调用失败，则重新选择一台
  5. 每分钟服务消费者和服务提供者向监控中心发送调用次数

### Dubbo配置
1. 注解：
   ```text
       基于注解可以快速的将程序配置，无需多余的配置信息，包含提供者和消费者。
   但是这种方式有一个弊端，有些时候配置信息并不是特别好找，无法快速定位。   
   ```

2. XML：
   ```text
       一般这种方式会和Spring做结合，相关的Service和Reference均使用Spring集成后的程序。
   通过这样的方式可以很方便的通过几个文件进行管理整个集群配置。可以快速定位也可以快速更改。
   ```

3. 代码：
   ```text
       基于代码方式配置。这种方式使用比较少，且这种方式适用于自己公司对其框架与Dubbo做深度集成时才会使用。
   ```
 
### Dubbo管理控制台 dubbo-admin
+ 作用：
     1. 服务管理
     2. 路由规则
     3. 动态配置
     4. 服务降级
     5. 访问控制
     6. 权重调整
     7. 负载均衡
     8. 管理功能
     
### Dubbo配置项说明
+ [dubbo:application(对应org.apache.dubbo.config.ApplicationConfig)](http://dubbo.apache.org/zh/docs/v2.7/user/references/xml/dubbo-application/)
   ```
   应用配置:
      1. name: 应用程序的名称，在dubbo-admin中也可以看到
      2. owner: 应用程序的负责人
      3. qosEnable：是否启动QoS，默认true
      4. qosPort：启动QoS绑定的端口号，默认：22222
      5. qosAcceptForeignIp：是否允许远程访问，默认：false
   ```
+ [dubbo:registry(对应org.apache.dubbo.config.RegistryConfig)](http://dubbo.apache.org/zh/docs/v2.7/user/references/xml/dubbo-registry/)
   ```
   注册中心配置:
      1. id: 注册中心id，当当前provider或consumer在多个注册中心时使用。
             在一些公司，会通过业务线的不同选择不同的注册中心，所以一般都会配置该值。
      2. address: 当前注册中心的访问地址。
      3. protocol: 当前注册中心使用的协议，也可以直接写在address中
      4. timeout: 注册中心请求超时时长，默认：5000，单位：毫秒
   ```
+ [dubbo:protocol(对应org.apache.dubbo.config.ProtocolConfig)](http://dubbo.apache.org/zh/docs/v2.7/user/references/xml/dubbo-protocol/)
   ```
   传输协议配置:
      1. id: 大公司可能因为各个部门技术栈不同，所以可能会选择使用不同的协议进行交互。
             在多个协议使用时，指定此值
      2. name: 指定协议的名称，默认：dubbo
   ```
+ [dubbo:service(对应org.apache.dubbo.config.ServiceConfig)](http://dubbo.apache.org/zh/docs/v2.7/user/references/xml/dubbo-service/)
   ```
   服务端的配置:
      1. interface: 指定当前需要进行对外暴露的接口是什么
      2. ref: 具体实现对象的引用，使用Spring去进行Bean管理时使用
      3. version: 对外暴露的版本号。消费者只会根据固定的版本号进行消费
      4. executes: 服务提供者每服务每方法最大可并行执行请求数，默认：0（不限制）
                   注意：设置不合理会导致服务阻塞或服务器运行不充分
   ```
+ [dubbo:reference(对应org.apache.dubbo.config.ReferenceConfig)](http://dubbo.apache.org/zh/docs/v2.7/user/references/xml/dubbo-reference/)
   ```
   消费者的配置:
     1. id: 指定该Bean注册到Spring中的id
     2. interface: 服务接口名
     3. version: 指定当前服务版本，与服务提供者的版本一致
     4. registry: 指定所具体使用的注册中心地址，这里是Spring中dubbo:registry中所声明的id
     5. mock: 服务接口调用失败Mock实现类名，该Mock类必须有一个无参构造函数，与Local的区别在于，Local总是被执行，而Mock只在出现非业务异常(比如超时，网络异常等)时执行，Local在远程调用之前执行，Mock在远程调用后执行。默认：false
     6. check: 启动时检查提供者是否存在，true报错，false忽略。默认：true
     7. retries: 远程服务调用重试次数，不包括第一次调用，不需要重试请设为0
                 注意：提供者是否有幂等性，否则可能出现数据不一致问题
                 注意：提供者是否有类似缓存机制，如果出现大面积错误时，可能因为重试机制导致雪崩
                 注意：使用该属性时，不要配置mock，不然不生效
   ```
+ [dubbo:method(对应org.apache.dubbo.config.MethodConfig)](http://dubbo.apache.org/zh/docs/v2.7/user/references/xml/dubbo-method/)
  ```
  方法配置:
     1. name: 方法名称，用于对这个方法名称的RPC调用进行特殊配置
     2. async: 是否异步，默认：false
  ```
## Dubbo高级应用实战
### SPI
```text
   SPI全称为Service Provider Interface，是JDK内置的一种服务提供发现机制。
目前有不少的框架用它来做服务的扩展发现，简单来说，它就是一种动态替换发现的
机制。使用SPI机制的优势是实现解耦，使得第三方服务模块的装配控制逻辑与调用
者的业务代码分离
```

### SPI约定：
1. 当服务提供者提供了接口的一种具体实现后，在META-INF/services目录下创建一个
   以“接口全限定名”为命名的文件，内容为实现类的全限定名
   
2. 接口实现类所在的jar包放在主程序的classpath中

3. 主程序通过java.util.ServiceLoader动态装载实现模块，它通过扫描META-INF/services
   目录下的配置文件找到实现类的全限定名，把类加载到JVM  
   
4. SPI的实现类必须携带一个无参构造方法

### Dubbo自己做SPi的目的
1. JDK标准的SPI会一次性实例化所有扩展点。如果所有的扩展实现初始化，那么系统启动会耗时，
   且如果没用上的实例也加载了，会很浪费系统资源
   
2. JDK的SPI如果有扩展点加载失败，那么所有的扩展点都无法使用

3. Dubbo提供了对扩展点包装的功能（Adaptive），并且还支持通过set方式对其他的扩展点进行注入

### Dubbo SPI中的Adaptive功能
```
Dubbo中Adaptive功能，主要解决的问题是如何动态的选择具体的扩展点
```

### Dubbo调用时拦截操作Activate
```
Dubbo中Filter接口和注解@Activate主要是用来做过滤器的
```

### Dubbo负载均衡策略
```
负载均衡（Load Balance），其实就是将请求分摊到多个操作单元上进行执行，从而共同完成工作任务。

负载均衡策略主要用于客户端存在多个服务提供者时进行选择某个提供者。

在集群负载均衡时，Dubbo提供了多种均衡策略（随机、轮询、最少活跃调用数、一致性hash），默认为random随机调用
   1. 随机（Random）：按权重设置随机概率
   2. 轮询（RoundRobin）：按公约后的权重设置轮询比例
   3. 最少活跃调用数（LeastActive）：相同活跃数的随机，活跃数指调用前后计数差
   4. 一致性Hash（ConsistentHash）：相同参数的请求总是发到同一提供者
```


## Dubbo源码分析
Dubbo的整体设计
服务注册与发现的源码剖析
Dubbo扩展SPI分析
集群容器的源码分析
网络通信原理分析